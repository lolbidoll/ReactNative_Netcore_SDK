package com.smartechpushreactnative;

import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.util.Log;

import androidx.annotation.NonNull;

import com.facebook.react.bridge.Callback;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import com.facebook.react.bridge.ReactMethod;
import com.facebook.react.bridge.ReadableMap;
import com.facebook.react.bridge.WritableMap;
import com.facebook.react.bridge.WritableNativeMap;
import com.facebook.react.bridge.WritableArray;
import com.facebook.react.bridge.WritableNativeArray;
import com.facebook.react.module.annotations.ReactModule;
import com.facebook.react.modules.core.DeviceEventManagerModule;

import com.netcore.android.smartechpush.SmartPush;
import com.netcore.android.smartechpush.notification.SMTNotificationReceivedListener;
import com.netcore.android.smartechpush.pnpermission.SMTNotificationPermissionCallback;
import com.netcore.android.SMTBundleKeys;
import org.json.JSONException;
import org.json.JSONObject;
import org.json.JSONArray;

import java.lang.ref.WeakReference;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

@ReactModule(name = SmartechPushReactNativeModule.NAME)
public class SmartechPushReactNativeModule extends ReactContextBaseJavaModule
    implements SMTNotificationReceivedListener {
  public static final String NAME = "SmartechPushReactNative";
  private SmartPush smartechpush = null;
  private final ReactApplicationContext reactContext;
  public static Intent mIntent = null;
  private static final String MODULE_NAME = "SmartechReactNative";
  private static final String SmartechNotificationReceived = "SmartechNotificationReceived";
  private static final String smtDeeplinkSourceIdentifier = "smtDeeplinkSource";
  private static final String smtDeeplinkIdentifier = "smtDeeplink";
  private static final String smtPayloadIdentifier = "smtPayload";
  private static final String smtCustomPayloadIdentifier = "smtCustomPayload";
  private static final String SmartechDeepLinkIdentifier = "deeplink";
  private static final String SmartechCustomPayloadIdentifier = "customPayload";
  private static final String TAG = SmartechPushReactNativeModule.class.getSimpleName();

  public SmartechPushReactNativeModule(ReactApplicationContext reactContext) {
    super(reactContext);
    this.reactContext = reactContext;
    initSDK();
  }

  private void initSDK() {
    if (smartechpush == null) {
      try {
        smartechpush = SmartPush.getInstance(new WeakReference<Context>(this.reactContext));
        smartechpush.setSMTNotificationReceivedListener(this);

      } catch (Throwable e) {
        e.printStackTrace();
      }
    }
  }

  @Override
  @NonNull
  public String getName() {
    return NAME;
  }


  @javax.annotation.Nullable
  @Override
  public Map<String, Object> getConstants() {
    final Map<String, Object> constants = new HashMap<>();
    constants.put(SmartechNotificationReceived, SmartechNotificationReceived);
    return constants;
  }

  @ReactMethod
  public static void init(Intent intent) {
    mIntent = intent;
  }

  /**
   * This method will be called when notification is received
   *
   * @param payload - notification payload
   */
  @Override
  public void onNotificationReceived(@NonNull String payload) {
    try {
      System.out.println("SmartPush ReactNative Module On Notification Received : " + payload);
      ReadableMap readableMap = jsonToWritableMap(new JSONObject(payload));
      this.reactContext.getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)
          .emit(SmartechNotificationReceived, readableMap);
    } catch (Throwable e) {
      e.printStackTrace();
    }
  }

  // Used to process intent.
  private ReadableMap processDeeplinkIntent(Intent intent) {
    WritableMap smtData = new WritableNativeMap();
    if (intent != null) {
      Bundle bundleExtra = intent.getExtras();
      if (bundleExtra != null) {
        String smtDeeplinkSource = "";
        String smtDeeplink = "";
        String smtPayload = "";
        String smtCustomPayload = "";

        if (bundleExtra.containsKey(SMTBundleKeys.SMT_KEY_DEEPLINK_SOURCE)) {
          smtDeeplinkSource = bundleExtra.getString(SMTBundleKeys.SMT_KEY_DEEPLINK_SOURCE);
        } else {
          Log.v(TAG, "does not have deeplink source.");
        }

        if (bundleExtra.containsKey(SMTBundleKeys.SMT_KEY_DEEPLINK)) {
          smtDeeplink = bundleExtra.getString(SMTBundleKeys.SMT_KEY_DEEPLINK);
        } else {
          Log.v(TAG, "does not have deeplink path.");
        }

        if (bundleExtra.containsKey(SMTBundleKeys.SMT_KEY_PAYLOAD)) {
          smtPayload = bundleExtra.getString(SMTBundleKeys.SMT_KEY_PAYLOAD);
        } else {
          Log.v(TAG, "does not have smt payload.");
        }

        if (bundleExtra.containsKey(SMTBundleKeys.SMT_KEY_CUSTOM_PAYLOAD)) {
          smtCustomPayload = bundleExtra.getString(SMTBundleKeys.SMT_KEY_CUSTOM_PAYLOAD);
        } else {
          Log.v(TAG, "does not have custom payload.");
        }

        try {
          smtData.putString(smtDeeplinkSourceIdentifier, smtDeeplinkSource);
          smtData.putString(smtDeeplinkIdentifier, smtDeeplink);
          ReadableMap rMapPayload = null;
          if(smtPayload != null && !smtPayload.isEmpty()) {
            rMapPayload = jsonToWritableMap(new JSONObject(smtPayload));
          }
          smtData.putMap(smtPayloadIdentifier, rMapPayload);
          ReadableMap rMapCustomPayload = null;
          if(smtCustomPayload != null && !smtCustomPayload.isEmpty()) {
            rMapCustomPayload = jsonToWritableMap(new JSONObject(smtCustomPayload));
          }
          smtData.putMap(smtCustomPayloadIdentifier, rMapCustomPayload);
          //This is for legacy support, will remove this after some releases when customers upgraded
          smtData.putString(SmartechDeepLinkIdentifier, smtDeeplink);
          smtData.putString(SmartechCustomPayloadIdentifier, smtCustomPayload);
        } catch (Throwable e) {
          e.printStackTrace();
        }

      }
    }
    return smtData;
  }

  // This method is used to opt push notifications.
  @ReactMethod
  public void optPushNotification(Boolean value) {
    try {
      smartechpush.optPushNotification(value);
    } catch (Throwable e) {
      e.printStackTrace();
    }
  }

  // This method is used to get the current status of opt push notification.
  @ReactMethod
  public void hasOptedPushNotification(Callback callback) {
    try {
      Boolean isPushNotificationOpted = smartechpush.hasOptedPushNotification();
      callbackHandler(callback, isPushNotificationOpted);
    } catch (Throwable e) {
      e.printStackTrace();
      callbackHandler(callback, "Exception: " + e.getMessage());
    }
  }

  // This method is used to get the device push token used by Smartech SDK.
  @ReactMethod
  public void getDevicePushToken(Callback callback) {
    try {
      String token = smartechpush.getDevicePushToken();
      callbackHandler(callback, token);
    } catch (Throwable e) {
      e.printStackTrace();
      callbackHandler(callback, "Exception: " + e.getMessage());
    }
  }

  // This method is used to set device push tokens which is used by SDK to send
  // notifications.
  @ReactMethod
  public void setDevicePushToken(String token) {
    try {
      smartechpush.setDevicePushToken(token);
    } catch (Throwable e) {
      e.printStackTrace();
    }
  }

    // This method would handle the push notification by smartech sdk
  @ReactMethod
  public void handlePushNotification(String notificationData, Callback callback) {
    try {
      if (!notificationData.isEmpty()) {
        boolean isPushFromSmartech = smartechpush.isNotificationFromSmartech(new JSONObject(notificationData));
        if (isPushFromSmartech) {
          smartechpush.handlePushNotification(notificationData);
        }
        callbackHandler(callback, isPushFromSmartech);
      } else {
        callbackHandler(callback, false);
      }
    } catch (Throwable e) {
      e.printStackTrace();
      callbackHandler(callback, false);
    }
  }

  /**
   * Exposed method to request the Notification Permission
   *
   * @param : Callback interface for getting status of Notification permission.
   */
  @ReactMethod
  public void requestNotificationPermission(Callback callback) {
    try {
      smartechpush.requestNotificationPermission(new SMTNotificationPermissionCallback() {
        @Override
        public void notificationPermissionStatus(int i) {
          callbackHandler(callback, i);
        }
      });
    } catch (Throwable e) {
      e.printStackTrace();
    }
  }

  /**
   * Exposed method to update the Notification Permission status
   *
   * @param pnPermissionStatus: status of permission either enabled
   *                            (SMTPNPermissionConstants.SMT_PN_PERMISSION_GRANTED)
   *                            or
   *                            disabled
   *                            (SMTPNPermissionConstants.SMT_PN_PERMISSION_DENIED)
   */
  @ReactMethod
  public void updateNotificationPermission(Integer pnPermissionStatus) {
    try {
      smartechpush.updateNotificationPermission(pnPermissionStatus);
    } catch (Throwable e) {
      e.printStackTrace();
    }
  }

  // This is empty method used in iOS only..
  @ReactMethod
  public void registerForPushNotificationWithAuthorizationOptions(boolean alert, boolean badge, boolean sound) {
  }

  // This method will be used to fetch already generated tokens for existings
  // users.
  @ReactMethod
  public void fetchAlreadyGeneratedTokenFromFCM() {
    try {
      smartechpush.fetchAlreadyGeneratedTokenFromFCM();
    } catch (Throwable e) {
      e.printStackTrace();
    }
  }

  // Used to handle callback.
  private void callbackHandler(Callback callback, Object response) {
    if (callback == null) {
      Log.i(TAG, "Callback is null.");
      return;
    }

    try {
      callback.invoke(response);
    } catch (Throwable e) {
      e.printStackTrace();
    }
  }

  // for convertind JSON to hashmap.
  private static HashMap<String, Object> jsonToHashMap(JSONObject jsonObject) throws JSONException {
    HashMap<String, Object> hashMap = new HashMap<>();
    Iterator<String> iterator = jsonObject.keys();
    try {
      while (iterator.hasNext()) {
        String key = iterator.next();
        Object value = jsonObject.get(key);
        hashMap.put(key, value);
      }
    } catch (Throwable e) {
      e.printStackTrace();
    }
    return hashMap;
  }

  private static WritableMap jsonToWritableMap(JSONObject jsonObject) {
    WritableMap writableMap = new WritableNativeMap();

    if (jsonObject == null) {
      return null;
    }

    Iterator<String> iterator = jsonObject.keys();
    if (!iterator.hasNext()) {
      return null;
    }

    while (iterator.hasNext()) {
      String key = iterator.next();

      try {
        Object value = jsonObject.get(key);

        if (value == null) {
          writableMap.putNull(key);
        } else if (value instanceof Boolean) {
          writableMap.putBoolean(key, (Boolean) value);
        } else if (value instanceof Integer) {
          writableMap.putInt(key, (Integer) value);
        } else if (value instanceof Double || value instanceof Long || value instanceof Float) {
          String str = String.valueOf(value);
          writableMap.putDouble(key, Double.parseDouble(str));
        } else if (value instanceof String) {
          writableMap.putString(key, value.toString());
        } else if (value instanceof JSONObject) {
          writableMap.putMap(key, jsonToWritableMap((JSONObject) value));
        } else if (value instanceof JSONArray) {
          writableMap.putArray(key, jsonArrayToWritableArray((JSONArray) value));
        } else if (value.getClass().isEnum()) {
          writableMap.putString(key, value.toString());
        }
      } catch (Throwable e) {
        e.printStackTrace();
      }
    }

    return writableMap;
  }

  private static WritableArray jsonArrayToWritableArray(JSONArray jsonArray) {
    WritableArray writableArray = new WritableNativeArray();

    if (jsonArray == null) {
      return null;
    }

    if (jsonArray.length() <= 0) {
      return null;
    }

    for (int i = 0; i < jsonArray.length(); i++) {
      try {
        Object value = jsonArray.get(i);

        if (value == null) {
          writableArray.pushNull();
        } else if (value instanceof Boolean) {
          writableArray.pushBoolean((Boolean) value);
        } else if (value instanceof Integer) {
          writableArray.pushInt((Integer) value);
        } else if (value instanceof Double || value instanceof Long || value instanceof Float) {
          String str = String.valueOf(value);
          writableArray.pushDouble(Double.parseDouble(str));
        } else if (value instanceof String) {
          writableArray.pushString(value.toString());
        } else if (value instanceof JSONObject) {
          writableArray.pushMap(jsonToWritableMap((JSONObject) value));
        } else if (value instanceof JSONArray) {
          writableArray.pushArray(jsonArrayToWritableArray((JSONArray) value));
        } else if (value.getClass().isEnum()) {
          writableArray.pushString(value.toString());
        }
      } catch (Throwable e) {
        e.printStackTrace();
      }
    }

    return writableArray;
  }

}
