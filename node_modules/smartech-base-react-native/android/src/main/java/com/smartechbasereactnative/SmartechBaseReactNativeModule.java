package com.smartechbasereactnative;

import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.location.Location;
import android.os.Build;
import android.os.Bundle;
import android.util.Log;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import com.facebook.react.bridge.Callback;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import com.facebook.react.bridge.ReactMethod;
import com.facebook.react.bridge.ReadableMap;
import com.facebook.react.bridge.WritableMap;
import com.facebook.react.bridge.WritableNativeMap;
import com.facebook.react.bridge.WritableArray;
import com.facebook.react.bridge.WritableNativeArray;
import com.facebook.react.module.annotations.ReactModule;
import com.facebook.react.modules.core.DeviceEventManagerModule;
import com.netcore.android.SMTBundleKeys;
import com.netcore.android.Smartech;

import org.json.JSONException;
import org.json.JSONObject;
import org.json.JSONArray;

import java.lang.ref.WeakReference;
import java.util.HashMap;
import java.util.Map;
import java.util.Iterator;
import android.os.Handler;
import android.os.Looper;

@ReactModule(name = SmartechBaseReactNativeModule.NAME)

public class SmartechBaseReactNativeModule extends ReactContextBaseJavaModule implements SmartechDeeplinkReceivers.OnDeeplinkReceived {
    public static final String NAME = "SmartechBaseReactNative";
    private Smartech smartech = null;
    private final ReactApplicationContext reactContext;
    private static final String TAG = SmartechBaseReactNativeModule.class.getSimpleName();

    private static final String SmartechDeeplink = "SmartechDeeplink";
    private static final String smtDeeplinkSourceIdentifier = "smtDeeplinkSource";
    private static final String smtDeeplinkIdentifier = "smtDeeplink";
    private static final String smtPayloadIdentifier = "smtPayload";
    private static final String smtCustomPayloadIdentifier = "smtCustomPayload";
    private static final String smtIsDeeplinkFromBg = "smtIsDeeplinkFromBg";

    //For legacy support
    private static final String SmartechDeeplinkNotification = "SmartechDeeplinkNotification";
    private static final String SmartechDeepLinkIdentifier = "deeplink";
    private static final String SmartechCustomPayloadIdentifier = "customPayload";

    public static boolean isSmartechDeeplinkInit = false;
    private final Long maxDelayTime = 3000L;
    private final Long delayDiff = 100L;
    private final Long startDelayTime = 400L;


    public SmartechBaseReactNativeModule(ReactApplicationContext reactContext) {
      super(reactContext);
      this.reactContext = reactContext;
      initSDK();
    }

    @Override
    @NonNull
    public String getName() {
        return NAME;
    }

    private void initSDK() {
      if (smartech == null) {
        try {
          smartech = Smartech.getInstance(new WeakReference<Context>(this.reactContext));
          SmartechDeeplinkReceivers.setRegisterCallback(this);
          SmartechDeeplinkReceivers deeplinkReceiver = new SmartechDeeplinkReceivers();
          IntentFilter filter = new IntentFilter("com.smartech.EVENT_PN_INBOX_CLICK");
          if (Build.VERSION.SDK_INT >= 34) {
            this.reactContext.registerReceiver(deeplinkReceiver, filter, Context.RECEIVER_EXPORTED);
          } else {
            this.reactContext.registerReceiver(deeplinkReceiver, filter);
          }
        } catch (Throwable e) {
          e.printStackTrace();
        }
      }
    }


 @javax.annotation.Nullable
  @Override
  public Map<String, Object> getConstants() {
    final Map<String, Object> constants = new HashMap<>();
    constants.put(SmartechDeeplink, SmartechDeeplink);
    constants.put(SmartechDeeplinkNotification, SmartechDeeplinkNotification);
    return constants;
  }


  // This method is used to track app install event.
  @ReactMethod
  public void trackAppInstall() {
    try {
      smartech.trackAppInstall();
    } catch (Throwable e) {
      e.printStackTrace();
    }
  }

  // This method is used to track app update event.
  @ReactMethod
  public void trackAppUpdate() {
    try {
      smartech.trackAppUpdate();
    } catch (Throwable e) {
      e.printStackTrace();
    }
  }

  // This method is used to track app install or update event by Smartech SDK itself.
  @ReactMethod
  public void trackAppInstallUpdateBySmartech() {
    try {
      smartech.trackAppInstallUpdateBySmartech();
    } catch (Throwable e) {
      e.printStackTrace();
    }
  }

  // This method is used to track custom event done by the user.
  @ReactMethod
  public void trackEvent(String eventName, ReadableMap payload) {
    try {
      HashMap<String, Object> hmapPayload = SmartechHelper.convertReadableMapToHashMap(payload);
      smartech.trackEvent(eventName, hmapPayload);
    } catch (Throwable e) {
      e.printStackTrace();
    }
  }

  /**
   * This method is used to send login event to Smartech backend.
   * This method should be called only when the app gets the user's identity
   * or when the user does a login activity in the application.
   */
  @ReactMethod
  public void login(String identity) {
    try {
      smartech.setUserIdentity(identity);
      smartech.login(identity);
    } catch (Throwable e) {
      e.printStackTrace();
    }
  }

  /**
   * This method would logout the user and clear identity on Smartech backend.
   * This method should be called only when the user log out of the application.
   */
  @ReactMethod
  public void logoutAndClearUserIdentity(Boolean isLogout) {
    try {
      smartech.logoutAndClearUserIdentity(isLogout);
    } catch (Throwable e) {
      e.printStackTrace();
    }
  }

  // This method would set the user identity locally and with all subsequent events this identity will be send.
  @ReactMethod
  public void setUserIdentity(String identity, Callback callback) {
    try {
      if (identity != null && identity.length() > 0) {
        smartech.setUserIdentity(identity);
        callbackHandler(callback, "Identity is set successfully.");
      } else {
        callbackHandler(callback, "Expected one non-empty string argument.");
      }
    } catch (Throwable e) {
      e.printStackTrace();
      callbackHandler(callback, "Exception: " + e.getMessage());
    }
  }

  // This method would get the user identity that is stored in the SDK.
  @ReactMethod
  private void getUserIdentity(Callback callback) {
    try {
      String userIdentity = smartech.getUserIdentity();
      callbackHandler(callback, userIdentity);
    } catch (Throwable e) {
      e.printStackTrace();
      callbackHandler(callback, "Exception: " + e.getMessage());
    }
  }

  // This method would clear the identity that is stored in the SDK.
  @ReactMethod
  public void clearUserIdentity() {
    try {
      smartech.clearUserIdentity();
    } catch (Throwable e) {
      e.printStackTrace();
    }
  }

  // This method is used to update the user profile.
  @ReactMethod
  public void updateUserProfile(ReadableMap profileData) {
    try {
      HashMap<String, Object> hmapProfile = SmartechHelper.convertReadableMapToHashMap(profileData);
      smartech.updateUserProfile(hmapProfile);
    } catch (Throwable e) {
      e.printStackTrace();
    }
  }

  // ----- GDPR Methods -----

  // This method is used to opt tracking.
  @ReactMethod
  public void optTracking(Boolean value) {
    try {
      smartech.optTracking(value);
    } catch (Throwable e) {
      e.printStackTrace();
    }
  }

  // This method is used to get the current status of opt tracking.
  @ReactMethod
  public void hasOptedTracking(Callback callback) {
    try {
      Boolean isTracking = smartech.hasOptedTracking();
      callbackHandler(callback, isTracking);
    } catch (Throwable e) {
      e.printStackTrace();
      callbackHandler(callback, "Exception: " + e.getMessage());
    }
  }

   //  This method is used to opt in-app messages.
    @ReactMethod
    public void optInAppMessage(Boolean value) {
        try {
            smartech.optInAppMessage(value);
        } catch (Throwable e) {
            e.printStackTrace();
        }
    }

    // This method is used to get the current status of opt in-app messages.
    @ReactMethod
    public void hasOptedInAppMessage(Callback callback) {
        try {
            Boolean isInAppOpted = smartech.hasOptedInAppMessage();
            callbackHandler(callback, isInAppOpted);
        } catch (Throwable e) {
            e.printStackTrace();
            callbackHandler(callback, "Exception: " + e.getMessage());
        }
    }


  // ----- Location Methods -----

  // This method is used to set the user's location to the SDK.
  @ReactMethod
  public void setUserLocation(Double latitude, Double longitude) {
    try {
      Location location = new Location("Smartech");
      location.setLatitude(latitude);
      location.setLongitude(longitude);
      smartech.setUserLocation(location);
    } catch (Throwable e) {
      e.printStackTrace();
    }
  }

  // ----- Helper Methods -----

  // This method is used to get the app id used by the Smartech SDK.
  @ReactMethod
  public void getAppId(Callback callback) {
    try {
      String appId = smartech.getAppID();
      callbackHandler(callback, appId);
    } catch (Throwable e) {
      e.printStackTrace();
      callbackHandler(callback, "Exception: " + e.getMessage());
    }
  }

  // This method is used to get the device unique id used by Smartech SDK.
  @ReactMethod
  public void getDeviceGuid(Callback callback) {
    try {
      String GUID = smartech.getDeviceUniqueId();
      callbackHandler(callback, GUID);
    } catch (Throwable e) {
      e.printStackTrace();
      callbackHandler(callback, "Exception: " + e.getMessage());
    }
  }

  // This method is used to get the current Smartech SDK version.
  @ReactMethod
  public void getSDKVersion(Callback callback) {
    try {
      String sdkVersion = smartech.getSDKVersion();
      callbackHandler(callback, sdkVersion);
    } catch (Throwable e) {
      e.printStackTrace();
      callbackHandler(callback, "Exception: " + e.getMessage());
    }
  }

  // Used to handle callback.
  private void callbackHandler(Callback callback, Object response) {
    if (callback == null) {
      Log.i(TAG, "Callback is null.");
      return;
    }

    try {
      callback.invoke(response);
    } catch (Throwable e) {
      e.printStackTrace();
    }
  }

  // for convertind JSON to hashmap.
  private static HashMap<String, Object> jsonToHashMap(JSONObject jsonObject) throws JSONException {
    HashMap<String, Object> hashMap = new HashMap<>();
    Iterator<String> iterator = jsonObject.keys();
    try {
      while (iterator.hasNext()) {
        String key = iterator.next();
        Object value = jsonObject.get(key);
        hashMap.put(key, value);
      }
    } catch (Throwable e) {
      e.printStackTrace();
    }
    return hashMap;
  }

  public void onDeeplinkReceived(Intent intent) {
    try {
      ReadableMap deeplinkPayload = processDeeplinkIntent(intent);
      System.out.println("Deeplink Pyload : " + deeplinkPayload);

      Boolean isFromBg = false;
      if (deeplinkPayload.hasKey(smtIsDeeplinkFromBg) && !deeplinkPayload.isNull(smtIsDeeplinkFromBg)) {
        isFromBg = deeplinkPayload.getBoolean(smtIsDeeplinkFromBg);
      }

      System.out.println("SmtIsDeeplinkFromBg value: " + isFromBg);

      if (isFromBg) {
        if (isSmartechDeeplinkInit) {
          sendDeeplinkCallback(deeplinkPayload);
        } else {
          Thread backgroundThread = new Thread(new Runnable() {
            @Override
            public void run() {
              handleDeeplinkInTerminatedState(startDelayTime, deeplinkPayload);
            }
          });
          System.out.println("Background thread started: " + backgroundThread.getName());
          backgroundThread.start();
        }
      } else {
        sendDeeplinkCallback(deeplinkPayload);
      }

    } catch (Throwable e) {
      e.printStackTrace();
    }
  }

  private static WritableMap jsonToWritableMap(JSONObject jsonObject) {
    WritableMap writableMap = new WritableNativeMap();

    if (jsonObject == null) {
      return null;
    }


    Iterator<String> iterator = jsonObject.keys();
    if (!iterator.hasNext()) {
      return null;
    }

    while (iterator.hasNext()) {
      String key = iterator.next();

      try {
        Object value = jsonObject.get(key);

        if (value == null) {
          writableMap.putNull(key);
        } else if (value instanceof Boolean) {
          writableMap.putBoolean(key, (Boolean) value);
        } else if (value instanceof Integer) {
          writableMap.putInt(key, (Integer) value);
        } else if (value instanceof Double || value instanceof Long || value instanceof Float) {
          String str = String.valueOf(value);
          writableMap.putDouble(key, Double.parseDouble(str));
        } else if (value instanceof String) {
          writableMap.putString(key, value.toString());
        } else if (value instanceof JSONObject) {
          writableMap.putMap(key, jsonToWritableMap((JSONObject) value));
        } else if (value instanceof JSONArray) {
          writableMap.putArray(key, jsonArrayToWritableArray((JSONArray) value));
        } else if (value.getClass().isEnum()) {
          writableMap.putString(key, value.toString());
        }
      } catch (Throwable e) {
        e.printStackTrace();
      }
    }

    return writableMap;
  }

  private static WritableArray jsonArrayToWritableArray(JSONArray jsonArray) {
    WritableArray writableArray = new WritableNativeArray();

    if (jsonArray == null) {
      return null;
    }

    if (jsonArray.length() <= 0) {
      return null;
    }

    for (int i = 0 ; i < jsonArray.length(); i++) {
      try {
        Object value = jsonArray.get(i);

        if (value == null) {
          writableArray.pushNull();
        } else if (value instanceof Boolean) {
          writableArray.pushBoolean((Boolean) value);
        } else if (value instanceof Integer) {
          writableArray.pushInt((Integer) value);
        } else if (value instanceof Double || value instanceof Long || value instanceof Float) {
          String str = String.valueOf(value);
          writableArray.pushDouble(Double.parseDouble(str));
        } else if (value instanceof String) {
          writableArray.pushString(value.toString());
        } else if (value instanceof JSONObject) {
          writableArray.pushMap(jsonToWritableMap((JSONObject) value));
        } else if (value instanceof JSONArray) {
          writableArray.pushArray(jsonArrayToWritableArray((JSONArray) value));
        } else if (value.getClass().isEnum()) {
          writableArray.pushString(value.toString());
        }
      } catch (Throwable e) {
        e.printStackTrace();
      }
    }

    return writableArray;
  }
    // Used to process intent.
  private ReadableMap processDeeplinkIntent(Intent intent) {
    WritableMap smtData = new WritableNativeMap();
    if (intent != null) {
      Bundle bundleExtra = intent.getExtras();
      if (bundleExtra != null) {
        String smtDeeplinkSource = "";
        String smtDeeplink = "";
        String smtPayload = "";
        String smtCustomPayload = "";
        Boolean isFromBg = false;

        if (bundleExtra.containsKey(SMTBundleKeys.SMT_KEY_DEEPLINK_SOURCE)) {
          smtDeeplinkSource = bundleExtra.getString(SMTBundleKeys.SMT_KEY_DEEPLINK_SOURCE);
        } else {
          Log.v(TAG, "does not have deeplink source.");
        }

        if (bundleExtra.containsKey(SMTBundleKeys.SMT_KEY_DEEPLINK)) {
          smtDeeplink = bundleExtra.getString(SMTBundleKeys.SMT_KEY_DEEPLINK);
        } else {
          Log.v(TAG, "does not have deeplink path.");
        }

        if (bundleExtra.containsKey(SMTBundleKeys.SMT_KEY_PAYLOAD)) {
          smtPayload = bundleExtra.getString(SMTBundleKeys.SMT_KEY_PAYLOAD);
        } else {
          Log.v(TAG, "does not have smt payload.");
        }

        if (bundleExtra.containsKey(SMTBundleKeys.SMT_KEY_CUSTOM_PAYLOAD)) {
          smtCustomPayload = bundleExtra.getString(SMTBundleKeys.SMT_KEY_CUSTOM_PAYLOAD);
        } else {
          Log.v(TAG, "does not have custom payload.");
        }

        if (bundleExtra.containsKey(SMTBundleKeys.SMT_KEY_IS_DEEPLINK_FROM_BG)) {
          isFromBg = bundleExtra.getBoolean(SMTBundleKeys.SMT_KEY_IS_DEEPLINK_FROM_BG,false);
        }

        try {
          smtData.putString(smtDeeplinkSourceIdentifier, smtDeeplinkSource);
          smtData.putString(smtDeeplinkIdentifier, smtDeeplink);
          ReadableMap rMapPayload = null;
          if(smtPayload != null && !smtPayload.isEmpty()) {
            rMapPayload = jsonToWritableMap(new JSONObject(smtPayload));
          }
          smtData.putMap(smtPayloadIdentifier, rMapPayload);
          ReadableMap rMapCustomPayload = null;
          if(smtCustomPayload != null && !smtCustomPayload.isEmpty()) {
            rMapCustomPayload = jsonToWritableMap(new JSONObject(smtCustomPayload));
          }
          smtData.putMap(smtCustomPayloadIdentifier, rMapCustomPayload);
          //This is for legacy support, will remove this after some releases when customers upgraded
          smtData.putString(SmartechDeepLinkIdentifier, smtDeeplink);
          smtData.putString(SmartechCustomPayloadIdentifier, smtCustomPayload);
          smtData.putBoolean(smtIsDeeplinkFromBg, isFromBg);
        } catch (Throwable e) {
          e.printStackTrace();
        }
      }
    }
    return smtData;
  }

  @ReactMethod
  public void setDeeplinkInit() {
    try {
      this.isSmartechDeeplinkInit = true;
    } catch (Throwable e) {
      e.printStackTrace();
    }
  }


  /**
   * Sends the deep link callback to the registered listener function.
   *
   * @param deeplinkPayload A [ReadableMap] containing the parameters of the deep link callback.
   *                        The keys represent the parameter names, and the values represent the parameter values.
   *                        This map typically includes information about the deep link response,
   *                        such as status, data, etc.
   */
  private void sendDeeplinkCallback(ReadableMap deeplinkPayload) {
    try {
      this.reactContext.getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class).emit(SmartechDeeplink, deeplinkPayload);
    } catch (Throwable t) {
      t.printStackTrace();
    }
  }


  /**
   * Handles the deep link when the application is in a terminated state, with retry behavior.
   *
   * This function is responsible for processing the deep link received when the application
   * is not running. It takes a [map] containing the parameters of the deep link and performs
   * the necessary actions. If the processing fails, it retries sending the deep link with
   * increasing delay times, up to a maximum of three retries.
   *
   * Retry condition is based on isSmartechDeeplinkInit value.
   *
   * @param delay Delay to pass handler for checking if listener is initialised.
   *
   * @param deeplinkPayload A [ReadableMap] containing the parameters of the deep link.
   *                        The keys represent the parameter names, and the values represent the parameter values.
   *                        This map typically includes information about the deep link, such as target screen,
   *                        data to be passed, etc.
   */
  private void handleDeeplinkInTerminatedState(Long delay, ReadableMap deeplinkPayload) {
    try {
      new Handler(Looper.getMainLooper()).postDelayed(new Runnable() {
        @Override
        public void run() {
          try {
            Log.i(TAG, "Deeplink Handler - delay is: " + delay + " seconds & isSmartechDeeplinkInit: " + isSmartechDeeplinkInit);

            if (isSmartechDeeplinkInit) {
              sendDeeplinkCallback(deeplinkPayload);
            } else {
              if (delay < maxDelayTime) {
                // Increment delay and call startHandler again
                handleDeeplinkInTerminatedState((delay + delayDiff), deeplinkPayload);
              } else {
                Log.i(TAG, "Maximum retries reached. Invoke Deeplink callback");
                sendDeeplinkCallback(deeplinkPayload);
              }
            }
          } catch (Throwable t) {
            t.printStackTrace();
            sendDeeplinkCallback(deeplinkPayload);
          }
        }
      }, delay);
    } catch (Throwable t) {
      t.printStackTrace();
      sendDeeplinkCallback(deeplinkPayload);
    }
  }

}
